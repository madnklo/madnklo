#! /usr/bin/env python

################################################################################
#
# Copyright (c) 2009 The MadGraph5_aMC@NLO Development team and Contributors
#
# This file is a part of the MadGraph5_aMC@NLO project, an application which 
# automatically generates Feynman diagrams and matrix elements for arbitrary
# high-energy processes in the Standard Model and beyond.
#
# It is subject to the MadGraph5_aMC@NLO license which should accompany this 
# distribution.
#
# For more information, visit madgraph.phys.ucl.ac.be and amcatnlo.web.cern.ch
#
################################################################################

"""This is the main executable, a simple frontend to set up the PYTHONPATH
and call immediately the command line interface scripts"""

import sys
if not sys.version_info[0] == 2 or sys.version_info[1] < 6:
    sys.exit('MadGraph/MadEvent 5 works only with python 2.6 or later (but not python 3.X).\n\
               Please upgrate your version of python.')

import os
import optparse

# Get the directory of the script real path (bin)
# and add it to the current PYTHONPATH

root_path = os.path.dirname(os.path.realpath( __file__ ))
p = os.path.abspath('../..')
sys.path.insert(0, p)

pjoin = os.path.join



class MyOptParser(optparse.OptionParser):
    
    class InvalidOption(Exception): pass

    def error(self, msg=''):
        raise MyOptParser.InvalidOption(msg)

# Write out nice usage message if called with -h or --help
usage = "usage: %prog [options] [FILE] "
parser = MyOptParser(usage=usage)
parser.add_option("-l", "--logging", default='INFO',
                  help="logging level (DEBUG|INFO|WARNING|ERROR|CRITICAL) [%default]")
parser.add_option("","--web", action="store_true", default=False, dest='web', \
                 help='force to be in secure mode')
parser.add_option("","--debug", action="store_true", default=False, dest='debug', \
                 help='force to launch debug mode')
parser_error = ''
done = False
for i in range(len(sys.argv)-1):
    try:
        (options, args) = parser.parse_args(sys.argv[1:len(sys.argv)-i])
        done = True
    except MyOptParser.InvalidOption, error:
        pass
    else:
        args += sys.argv[len(sys.argv)-i:]
if not done:
    # raise correct error:
    try:
        (options, args) = parser.parse_args()
    except MyOptParser.InvalidOption, error:
        print error
        sys.exit(2)

if len(args) == 0:
    args = ''

import logging
logger = logging.getLogger('madevent.stdout') # -> stdout
logger_stderr = logging.getLogger('madevent.stderr') # ->stderr
import madgraph.iolibs.export_ME7 as export_ME7
from models.check_param_card import ParamCardRule
import madgraph.interface.madevent_interface as madevent
import madgraph.various.banner as banner_mod


export_dir = os.path.abspath('..')
opt = {'output_dir':pjoin(export_dir,'Source'),
       'param_card':pjoin(export_dir,'Cards','param_card.dat'),
       'run_card':pjoin(export_dir,'Cards','run_card.dat'),
       'forbid_MadLoopInit': False}

ParamCardRule().check_param_card(pjoin(export_dir, 'Cards','param_card.dat'))
proc_characteristics = banner_mod.ProcCharacteristic().write(pjoin(export_dir,'SubProcesses','proc_characteristics'))
proc_characteristics = banner_mod.ProcCharacteristic(pjoin(export_dir,'SubProcesses','proc_characteristics'))

if args[0] in ['param', 'all']:
    # TODO: import MadEventCmd functions
    # read model name from proc_card
    for line in open(os.path.join(export_dir,'Cards','proc_card_mg5.dat')):
        line = line.split('#')[0]
        if line.startswith('import') and 'model' in line:
            model = line.split()[2]   
    tmp_model = os.path.basename(model)
    if tmp_model == 'mssm' or tmp_model.startswith('mssm-'):
        if not '--param_card=' in line:
            param_card = pjoin(export_dir, 'Cards','param_card.dat')
            mg5_param = pjoin(export_dir, 'Source', 'MODEL', 'MG5_param.dat')
	        #TODO: check call to convert_to_.. and check_valid_..
            ParamCardRule().convert_to_mg5card(param_card, mg5_param)
            ParamCardRule().check_valid_param_card(mg5_param)
            opt['param_card'] = pjoin(export_dir, 'Source', 'MODEL', 'MG5_param.dat')
    else:
        from models import check_param_card
        check_param_card.check_valid_param_card(opt['param_card'])

    logger.debug('write compile file for card: %s' % opt['param_card']) 
    param_card = check_param_card.ParamCard(opt['param_card'])
    outfile = pjoin(opt['output_dir'], 'param_card.inc')
    ident_card = pjoin(export_dir,'Cards','ident_card.dat')
    if os.path.isfile(pjoin(export_dir,'bin','internal','ufomodel','restrict_default.dat')):
        default = pjoin(export_dir,'bin','internal','ufomodel','restrict_default.dat')
    elif os.path.isfile(pjoin(export_dir,'bin','internal','ufomodel','param_card.dat')):
        default = pjoin(export_dir,'bin','internal','ufomodel','param_card.dat')
    elif not os.path.exists(pjoin(export_dir,'bin','internal','ufomodel')):
        fsock = open(pjoin(export_dir,'Source','param_card.inc'),'w')
        fsock.write(' ')
        fsock.close()
        default = pjoin(export_dir,'Cards','param_card_default.dat')
	    #if mode == 'all':
	    #    self.do_treatcards('', 'run', opt)
	    #return
    else:
        devnull = open(os.devnull,'w')
	    #subprocess.call([sys.executable, 'write_param_card.py'],
	    #	     cwd=pjoin(export_dir,'bin','internal','ufomodel'),
	    #	     stdout=devnull)
        devnull.close()
        default = pjoin(export_dir,'bin','internal','ufomodel','param_card.dat')

    need_mp = proc_characteristics['loop_induced']             
    param_card.write_inc_file(outfile, ident_card, default, need_mp=need_mp)

if args[0] in ['run', 'all']:
    run_card = banner_mod.RunCardNLO(pjoin(export_dir,'Cards','NLO_run_card.dat'))
    n_initial = run_card['lpp1']+run_card['lpp2']
    if n_initial == 1:
        run_card['lpp1'] =  0
        run_card['lpp2'] =  0
        run_card['ebeam1'] = 0
        run_card['ebeam2'] = 0

    run_card.write_include_file(opt['output_dir'])

if proc_characteristics['loop_induced'] and mode in ['loop', 'all']:
    MadLoopparam = banner_mod.MadLoopParam(pjoin(export_dir, 
                                                  'Cards', 'MadLoopParams.dat'))
    # The writing out of MadLoop filter is potentially dangerous
    # when running in multi-core with a central disk. So it is turned
    # off here. If these filters were not initialized then they will 
    # have to be re-computed at the beginning of each run.
    if 'WriteOutFilters' in MadLoopparam.user_set and \
                                       MadLoopparam.get('WriteOutFilters'):
        logger.info(
"""You chose to have MadLoop writing out filters. 
Beware that this can be dangerous for local multicore runs.""")
    MadLoopparam.set('WriteOutFilters',False, changeifuserset=False)
            
            # The conservative settings below for 'CTModeInit' and 'ZeroThres'
            # help adress issues for processes like g g > h z, and g g > h g
            # where there are some helicity configuration heavily suppressed 
            # (by several orders of magnitude) so that the helicity filter 
            # needs high numerical accuracy to correctly handle this spread in
            # magnitude. Also, because one cannot use the Born as a reference
            # scale, it is better to force quadruple precision *for the 
            # initialization points only*. This avoids numerical accuracy issues
            # when setting up the helicity filters and does not significantly
            # slow down the run.
#            self.MadLoopparam.set('CTModeInit',4, changeifuserset=False)
            # Consequently, we can allow for a finer threshold for vanishing
            # helicity configuration
#            self.MadLoopparam.set('ZeroThres',1.0e-11, changeifuserset=False)

#           It is a bit superficial to use the level 2 which tries to numerically
#           map matching helicities (because of CP symmetry typically) together.
#           It is useless in the context of MC over helicities and it can 
#           potentially make the helicity double checking fail.
    MadLoopparam.set('HelicityFilterLevel',1, changeifuserset=False)

#           To be on the safe side however, we ask for 4 consecutive matching
#           helicity filters.
    MadLoopparam.set('CheckCycle',4, changeifuserset=False)
            
            # For now it is tricky to have each channel performing the helicity
            # double check. What we will end up doing is probably some kind
            # of new initialization round at the beginning of each launch
            # command, to reset the filters.    
    MadLoopparam.set('DoubleCheckHelicityFilter',False,changeifuserset=False)
          
            # Thanks to TIR recycling, TIR is typically much faster for Loop-induced
            # processes when not doing MC over helicities, so that we place OPP last.
    run_card = banner_mod.RunCard(opt['run_card'])
    if run_card['nhel'] == 0:
        if 'MLReductionLib' in MadLoopparam.user_set and \
            (MadLoopparam.get('MLReductionLib').startswith('1') or
             MadLoopparam.get('MLReductionLib').startswith('6')):
            logger.warning(
    """You chose to set the preferred reduction technique in MadLoop to be OPP (see parameter MLReductionLib).
    Beware that this can bring significant slowdown; the optimal choice --when not MC over helicity-- being to first start with TIR reduction.""")
                # We do not include GOLEM for now since it cannot recycle TIR coefs yet.
        MadLoopparam.set('MLReductionLib','7|6|1', changeifuserset=False)
    else:
        if 'MLReductionLib' in MadLoopparam.user_set and \
            not (MadLoopparam.get('MLReductionLib').startswith('1') or
                 MadLoopparam.get('MLReductionLib').startswith('6')):
            logger.warning(
    """You chose to set the preferred reduction technique in MadLoop to be different than OPP (see parameter MLReductionLib).
    Beware that this can bring significant slowdown; the optimal choice --when MC over helicity-- being to first start with OPP reduction.""")
        MadLoopparam.set('MLReductionLib','6|7|1', changeifuserset=False)

            # Also TIR cache will only work when NRotations_DP=0 (but only matters
            # when not MC-ing over helicities) so it will be hard-reset by MadLoop
            # to zero when not MC-ing over helicities, unless the parameter
            # Force_ML_Helicity_Sum is set to True in the matrix<i>.f codes.
    if run_card['nhel'] == 0:
        if ('NRotations_DP' in MadLoopparam.user_set and \
                                     MadLoopparam.get('NRotations_DP')!=0) or \
            ('NRotations_QP' in MadLoopparam.user_set and \
                                         MadLoopparam.get('NRotations_QP')!=0):
            logger.warning(
    """You chose to also use a lorentz rotation for stability tests (see parameter NRotations_[DP|QP]).
    Beware that, for optimization purposes, MadEvent uses manual TIR cache clearing which is not compatible
    with the lorentz rotation stability test. The number of these rotations to be used will be reset to 
    zero by MadLoop. You can avoid this by changing the parameter 'FORCE_ML_HELICITY_SUM' int he matrix<i>.f
    files to be .TRUE. so that the sum over helicity configurations is performed within MadLoop (in which case
    the helicity of final state particles cannot be speicfied in the LHE file.""")
        MadLoopparam.set('NRotations_DP',0,changeifuserset=False)
        MadLoopparam.set('NRotations_QP',0,changeifuserset=False)
    else:
                # When MC-ing over helicities, the manual TIR cache clearing is
                # not necessary, so that one can use the lorentz check
                # Using NRotations_DP=1 slows down the code by close to 100%
                # but it is typicaly safer.
                # self.MadLoopparam.set('NRotations_DP',0,changeifuserset=False)
                # Revert to the above to be slightly less robust but twice faster.
        MadLoopparam.set('NRotations_DP',1,changeifuserset=False)
        MadLoopparam.set('NRotations_QP',0,changeifuserset=False)                
            
            # Finally, the stability tests are slightly less reliable for process
            # with less or equal than 4 final state particles because the 
            # accessible kinematic is very limited (i.e. lorentz rotations don't
            # shuffle invariants numerics much). In these cases, we therefore
            # increase the required accuracy to 10^-7.
            # This is important for getting g g > z z [QCD] working with a
            # ptheavy cut as low as 1 GeV.  
    if proc_characteristics['nexternal']<=4:
        if ('MLStabThres' in MadLoopparam.user_set and \
                                   MadLoopparam.get('MLStabThres')>1.0e-7):
            logger.warning(
    """You chose to increase the default value of the MadLoop parameter 'MLStabThres' above 1.0e-7.
    Stability tests can be less reliable on the limited kinematic of processes with less or equal
    than four external legs, so this is not recommended (especially not for g g > z z).""")
        MadLoopparam.set('MLStabThres',1.0e-7,changeifuserset=False)
    else:
        MadLoopparam.set('MLStabThres',1.0e-4,changeifuserset=False)            

            #write the output file
    MadLoopparam.write(pjoin(export_dir,"SubProcesses","MadLoop5_resources",
                                          "MadLoopParams.dat"))
            
if proc_characteristics['loop_induced'] and mode in ['loop', 'all']:
    # TODO: import self.exec_cmd function
    # Now Update MadLoop filters if necessary (if modifications were made to
    # the model parameters).
    if need_MadLoopFilterUpdate:
        logger.debug('Changes to the %s parameters'%type_of_change+\
                  ' have been detected. Madevent will then now reinitialize'+\
                                                            ' MadLoop filters.')
        self.exec_cmd('initMadLoop -r -f')
    # The need_MadLoopInit condition is just there so as to avoid useless
    # printout if there is not initialization to be performed. But even
    # without it, and because we call 'initMadLoop' without the '-r' option
    # no time would be wasted anyway, since the existing filters would not
    # be overwritten.
    elif not opt['forbid_MadLoopInit'] and \
                                   MadLoopInitializer.need_MadLoopInit(self.me_dir):
        self.exec_cmd('initMadLoop -f')



try:
# Remove lock file
    os.remove(os.path.join(root_path,os.pardir, 'RunWeb'))
except:
    pass
